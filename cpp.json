{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Macro Functions": {
		"prefix": "vandan",
		"body": [
			"\t\t\t/**************************************",
			"\t\t\t*                                     *",
			"\t\t\t*            sasta_samurai            *",
			"\t\t\t*                                     *",
			"\t\t\t**************************************/",
			"#include<bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace std;",
			"using namespace chrono;",
			"using namespace __gnu_pbds;",
			"#define ll long long int",
			"#define ld long double",
			"#define cd complex<ld>",
			"#define pi pair<int, int>",
			"#define pl pair<ll,ll>",
			"#define pd pair<ld,ld>",
			"#define vi vector<int>",
			"#define vs vector<string>",
			"#define vd vector<ld>",
			"#define vl vector<ll>",
			"#define vpi vector<pi> ",
			"#define vpl vector<pl> ",
			"#define vvl vector<vl> ",
			"#define vcd vector<cd>",
			"#define st string",
			"#define mll map<ll,ll>",
			"#define loop(i,a,b) for(ll i=a;i<b;++i)",
			"#define rloop(i,a,b) for(ll i=a;i>=b;i--)",
			"#define in(a,n) for(ll i=0;i<n;++i) cin>>a[i];",
			"#define pb push_back",
			"#define mk make_pair",
			"#define all(v) v.begin(),v.end()",
			"#define rall(v) v.rbegin(),v.rend()",
			"#define dis(v) for(auto i:v)cout<<i<<\" \";cout<<endl;",
			"#define display(arr,n) for(int i=0; i<n; i++)cout<<arr[i]<<\" \";cout<<endl;",
			"#define fast ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);srand(time(NULL));",
			"#define l(a) a.length()",
			"#define maxx(a,b) max(1ll*(a),1ll*(b));",
			"#define minn(a,b) min(1ll*(a),1ll*(b));",
			"#define fr first",
			"#define sc second",
			"#define mod 1000000007",
			"#define endl \"\\n\" ",
			"#define yes cout<<\"YES\"<<endl;\n#define no cout<<\"NO\"<<endl;",
			"#ifndef ONLINE_JUDGE",
			"#define debug(x) cerr << #x<<\" \"; _print(x); cerr << endl;",
			"#else",
			"#define debug(x);",
			"#endif",
			"#define debug(x) cerr << #x<<\" \"; _print(x); cerr << endl;",
			"void _print(ll t) {cerr << t;}",
			"void _print(int t) {cerr << t;}",
			"void _print(string t) {cerr << t;}",
			"void _print(char t) {cerr << t;}",
			"void _print(double t) {cerr << t;}",
			"template <class T, class V> void _print(pair <T, V> p);",
			"template <class T> void _print(vector <T> v);",
			"template <class T> void _print(set <T> v);",
			"template <class T, class V> void _print(map <T, V> v);",
			"template <class T> void _print(multiset <T> v);",
			"template <class T> void _print(queue <T> v) {cerr << \"{\"; while(v.size()){ _print(v.front()); cerr << \" \";v.pop();} cerr << \"}\"; }",
			"template <class T> void _print(stack <T> v) {stack<T> a; while(v.size()) a.push(v.top()), v.pop(); cerr << \"{\";  while(a.size()){ _print(a.top()); cerr << \" \";a.pop();}  cerr << \"}\"; }",
			"template <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.fr); cerr << \",\"; _print(p.sc); cerr << \"}\";}",
			"template <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
			"template <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}\n",
			"template<class T>",
			"using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"template<class key, class value, class cmp = std::less<key>>",
			"using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;",
			"ll add(ll x,ll y)  {ll ans = x+y; return (ans>=mod ? ans - mod : ans);}",
			"ll sub(ll x,ll y)  {ll ans = x-y; return (ans<0 ? ans + mod : ans);}",
			"ll mul(ll x,ll y)  {ll ans = x*y; return (ans>=mod ? ans % mod : ans);}\n\n",
			"//string decimaltobinary (ll n,ll length) {return bitset<length>(n).to_string();}",
			"const int MOD = 1000000007;",
			"void google(int t) {cout << \"Case #\" << t << \": \";}",
			"ll binaryMultiply(ll a, ll b,ll M=mod){ll ans = 0;while (b) {if (b & 1){ans = (ans + a) % M;}a = (a + a) % M;b >>= 1;} return ans;}",
			"ll binaryExponentiation(ll a, ll b,ll M=mod){a %= M;ll ans = 1;while (b){if (b & 1){if(M>mod) ans = binaryMultiply(ans, a);else ans = (ans * 1LL * a) % M;}if(M>mod) a = binaryMultiply(a, a);else a = (a * 1LL * a) % M;b >>= 1;}return ans;}",
			"vector<ll> sieve(ll n) {ll *arr = new ll[n + 1](); vector<ll> vect; for (ll i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for (ll j = 2 * i; j <= n; j += i)arr[j] = 1;} return vect;}",
			"void extendgcd(ll a, ll b, vi &v) {if (b == 0) {v[0] = 1; v[1] = 0; v[2] = a; return ;} extendgcd(b, a % b, v); ll x = v[1]; v[1] = v[0] - v[1] * (a / b); v[0] = x; return;} //pass a vector of size 3",
			"ll mminv(ll a, ll M) {vi arr(3); extendgcd(a, M, arr); return arr[0];} //for non prime M",
			"ll mminvprime(ll a, ll M) {return binaryExponentiation(a, M - 2, M);}//for prime M",
			"ll phi(ll n){ll result=n;for(ll i=2;i*i<=n;i++){if(n%i==0){while(n%i==0) n/=i;result-=result/i;}}if(n>1) result-=result/n; return result;}",
			"const int MX = 100001;",
			"const ll MOD1 = 1e9+7;",
			"const ll MOD9 = 998244353;",
			"const ll INF = 1e18;",
			"const int TWO_MOD_INV = 500000004;",
			"bool sq(ll n){",
			"\tll i = sqrt(n);",
			"\treturn (i*i == n);",
			"}",
			"bool check(ll i,ll j,ll n,ll m){",
			"\tif(i<0 || j<0 || i>=n || j>=m){",
			"\t\treturn false;",
			"\t}",
			"\treturn true;",
			"}",
			"void SieveOfEratosthenes(int n)",
			"{",
    		"\tbool prime[n + 1];",
    		"\tmemset(prime, true, sizeof(prime)); ",
			"\tfor (int p = 2; p * p <= n; p++)",
    		"\t{",
        	"\tif (prime[p] == true)",
        	"\t{",
            "\tfor (int i = p * p; i <= n; i += p)",
            "\t\tprime[i] = false;",
        	"\t}",
    		"\t}",
    		"\tfor (int p = 2; p <= n; p++)",
        	"\tif (prime[p])",
            "\tcout << p << \" \";",
			"}",
			"ll total_sum(ll start,ll end){",
			"\treturn (",
			"\t\t(((end - start + 1) % MOD) * ((start + end) % MOD) % MOD)",
			"\t\t* TWO_MOD_INV % MOD",
			"\t);",
			"}",
			"/* sparse table */",
			"void build(vl &a){",
			"ll sparse[200010][32];",
			"ll lg[200010];",
			"\t// memset(sparse,-1,sizeof sparse);",
			"\tll n = a.size();",
			"\tfor (int i=2;i<=n;i++) lg[i]=lg[i>>1]+1;",
			"\tfor(int i=0;i<n;i++){",
			"\t\tsparse[i][0] = a[i];",
			"\t}",
			"\tfor(int j=1;j<30;j++){",
			"\t\tfor(int i=0;i+(1<<j) <= n;i++){",
			"\t\t\tsparse[i][j] = max(sparse[i][j-1],sparse[i+(1<<(j-1))][j-1]);",
			"\t\t}",
			"\t}",
			"}",
			"/*ncr function*/",
			"ll binexp(ll a,ll b, ll m){",
			"\tll res = 1;",
			"\twhile(b>0){",
			"\t\tif(b&1){",
			"\t\t\tres = (res*a)%m;",
			"\t\t}",
			"\t\ta = (a*a)%m;",
			"\t\tb >>= 1;",
			"\t}",
			"\treturn res;",
			"}",
			"vl fact(1e6+1,1);",
			"void factorial(){",
			"\tfor(int i=1;i<=1e6;i++){",
			"\t\tfact[i] = (fact[i-1]*i)%mod;",
			"\t}",
			"}",
			"ll ncr(ll n,ll k){",
			"\tll ans = fact[n];",
			"\tll den = (fact[n-k]*fact[k])%mod;",
			"\tden = binexp(den,mod-2,mod);",
			"\tans = (ans*den)%mod;",
			"\treturn ans;",
			"}",
			"// important syntaxes here",
			"/* sparse table*/",
			"// ll d = lg[abs(x1-x2)];",
			"// ll max_height = max(sparse[min(x1,x2)-1][d],sparse[max(x1,x2)-(1<<d)][d]);",
			"/*ordered_set*/",
			"//order_of_key (k) : Number of items strictly smaller than k .",
			"//find_by_order(k) : K-th element in a set (counting from zero).",
			"//cout<<setprecision(15)<<pow(1.1,x)",
			"//*max_element(all(vec))",
			"//count(all(vec),0ll))",
			"/*heap*/",
			"//priority_queue<int, vector<int>, greater<int>> p;",
			"void solve()",
			"{",
			"\tll n; cin>>n;",
			"\tvl a(n);",
			"\tloop(i,0,n){",
			"\t\tcin>>a[i];",
			"\t}",
			"",
			"}",
			"int main()\n{",
			"\tfast",
			"\tint\tt=1;",
			"\tcin>>t;",
			"\tfactorial();",
			"\twhile(t--)",
			"\t{",
			"\t\tsolve();",
			"\t}",
			"\t$0\n\treturn 0;",
			"}",
		],
		"description": "Important"
	},
	"Test Case": {
		"prefix": "tc",
		"body": [
			"ll t;",
			"cin>>t;",
			"while(t--)",
			"{",
			   "",
			"}",
		],
		"description": "Important"
	},
	"HI": {
		"prefix": "hi",
		"body": [
			"cout<<\"hi\"<<endl;",
		],
		"description": "Important"
	},
	"prime": {
		"prefix": "prime",
		"body": [
			"vl prime(ll n)",
			"{",
			"\tvector<ll> prime_factor;",
			"\tfor(ll i=2;i*i<=n;i++){",
			"\t\tif(n%i == 0){",
			"\t\t\twhile(n%i==0)   n/=i;",
			"\t\t\tprime_factor.pb(i);",
			"\t\t}",
			"\t}",
			"\tif(n>1) prime_factor.pb(n);",
			"\treturn prime_factor;",
			"\tsort(all(prime_factor));",
			"\tdis(prime_factor)",
			"}",
		]
	},
	"millar": {
		"prefix": "millar",
		"body": [
			"ll binpower(ll base, ll e, ll m) {",
			"\tll result = 1;",
			"\tbase %= m;",
			"\twhile (e) {",
			"\tif (e & 1)",
			"\t\t\tresult = (ll)result * base % m;",
			"\t\tbase = (ll)base * base % m;",
			"\t\te >>= 1;",
			"\t}",
			"\treturn result;",
			"}",
			"bool check_composite(ll n, ll a, ll d, int s) {",
			"\tll x = binpower(a, d, n);",
			"\tif (x == 1 || x == n - 1)",
			"\treturn false;",
			"\tfor (int r = 1; r < s; r++) {",
			"\tx = (ll)x * x % n;",
			"\tif (x == n - 1)",
			"\ttreturn false;",
			"\t}",
			"\treturn true;",
			"};",
			"bool MillerRabin(ll n) {",
			"\tif (n < 2)",
			"\treturn false;",
			"",
			"\tint r = 0;",
			"\tll d = n - 1;",
			"\twhile ((d & 1) == 0) {",
			"\td >>= 1;",
			"\tr++;",
			"\t}",
			"\tfor (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {",
			"\tif (n == a)",
			"\t\treturn true;",
			"\tif (check_composite(n, a, d, r))",
			"\t\treturn false;",
			"\t}",
			"\treturn true;",
			"}",
		]
	},
	"evenodd": {
		"prefix": "evenodd",
		"body": [
			"ll odd=0,even=0;",
        	"loop(i,0,n) ",
        	"{",
            "\tll temp;",
            "\tcin>>temp;",
            "\tif(temp%2 == 0) even++;",
            "\telse odd++;",
        	"}",
		]
	},
	"pow2": {
		"prefix": "pow2",
		"body": [
			"vl pow2;",
    		"pow2.push_back(1);",
    		"while(pow2.back() < 1e9) pow2.push_back(pow2.back()*2);",
		]
	},
	"bnsearch": {
		"prefix": "bnsearch",
		"body": [
			"int binarySearchCount(int arr[], int n, int key)",
			"{",
    		"\tint left = 0, right = n;",
    		"\tint mid;",
    		"\twhile (left < right) {",
    		"\t\tmid = (right + left) >> 1;",
    		"\t\tif (arr[mid] == key) {",
    		"\t\t\twhile (mid + 1 < n && arr[mid + 1] == key)",
    		" mid++;",
    		"break;",
			"}",
    		"\t\telse if (arr[mid] > key)",
    		"\t\t\tright = mid;",
    		"\t\telse",
    		"left = mid + 1;",
			"}",
    		"while (mid > -1 && arr[mid] > key)",
    		"mid--;",
    		"return mid + 1;",
			"}",
		]
	},
	"sieve": {
		"prefix": "sieve",
		"body": [
			"void SieveOfEratosthenes(int n)",
			"{",
    		"\tbool prime[n + 1];",
    		"\tmemset(prime, true, sizeof(prime)); ",
			"\tfor (int p = 2; p * p <= n; p++)",
    		"\t{",
        	"\tif (prime[p] == true)",
        	"\t{",
            "\tfor (int i = p * p; i <= n; i += p)",
            "\t\tprime[i] = false;",
        	"\t}",
    		"\t}",
    		"\tfor (int p = 2; p <= n; p++)",
        	"\tif (prime[p])",
            "\tcout << p << \" \";",
			"}",
		]
	},
	"divison": {
		"prefix": "divison",
		"body": [
			"int numerator=22,denominator=7;",
    		"cout<<numerator/denominator<<\".\";",
    		"numerator %= denominator;",
    		"int cnt=12;",
    		"while(cnt--)",
    		"{",
    		"\tif(numerator<denominator) numerator*=10;",
    		"\tcout<<numerator/denominator;",
    		"\tnumerator%=denominator;",
    		"}",
		]
	},
	"fenwick": {
		"prefix": "fenwick",
		"body": [
			"ll N=1e5+1;",
			"vl fenwick(N,0);",
			"void update(ll i,ll add){",
			"\twhile(i<N){",
			"\t\tfenwick[i] += add;",
			"\t\ti = i + (i&-i);",
			"\t}",
			"}",
			"ll sum(ll i){",
			"\tll s=0;",
			"\twhile(i>0){",
			"\t\ts += fenwick[i];",
			"\t\ti = i - (i&-i);",
			"\t}",
			"\treturn s;",
			"}",
		]
	}
}
